Legend:     [x] Finished task   [-] Partially complete task   [ ] Unstarted task
             -  Information      o  Option

High importance:

[x] Compound literals
[x] Anonymous unions and structs
[-] Compile time evaluation
    [x] enum constants
    [x] Array sizes
    [x] sizeof
    [ ] Side effects
[ ] const
[x] char
[ ] Review type compatibility
[ ] Numeric type coercion: widening & narrowing
[ ] Type completeness
[-] Varargs
[-] enum
[ ] extern
[x] argc & argv passing
[x] continue
[-] static
    [ ] Function linkage
    [ ] Disallow all others?
[ ] Disallow global variables
[-] Modules
    [ ] Separated namespaces
    [ ] Include once only
    [ ] Different dialect?
        - No impls

Medium:

[-] Typedef

Low:

[ ] main conformance
[ ] % /
[ ] Pretty printing control by command line
[ ] string
[ ] New IR
    - Expression only (to start with)
[ ] Designated initializers in compound literals
[ ] Lexer errors
    [ ] Multichar
    [ ] EOF without EOL
    [ ] Unended comment / string / char
    [ ] Unrecognised escape
[ ] Modules
    [ ] header & using, special meaning?
[ ] Initializing arrays from strings
[ ] Expand eval.c
    [ ] String literals and indexing
    [ ] Records and arrays


Other issues:

[ ] Add symbol size back to debug output
[ ] Use jump tables in tag string lookup
[ ] Use enums for BOPs and UOPs
[ ] vsystem -> systemf

Lexer:

[ ] Lexing of pp
[ ] More on char and str lexing
    More?

Parser:

[ ] Param name clash !!!!
[ ] Fix bop location thingy (astCreateBOP(o, l))
[-] Symbol shadowing
[ ] Get tokenMatch to guess whether to skip based on similarity of tokens
[ ] Line that starts with undeclared ident... assume decl?
[ ] Complain about keywords as idents
[ ] Disallow initializations inside normal expressions
[x] Search paths are still broken
    - Don't add current path to search, only use it within
[ ] Implicit declarations on error
[ ] Error for unnamed structs/unions that don't define variables
	- OUTSIDE structs/unions (those would be anonymous, not unnamed... because the difference is obvious)

Semantic analyzer:

[ ] Array size detection (basic x[] = {...})
    - analyzer-decl.c
[x] Do analyzerArrayLiteral lits properly
[ ] Check that fn impl and var init are semantically valid
[x] Move sym checking code from analyzerDecl to analyzerDeclIdentLiteral?
    Why not?
    Might be different for different kinds of symbol
[-] Make sure prototypes and implementation match exactly (static)
[ ] Empty decl warning?
[ ] Initialization of extern and typedef
[x] Use the DT of passed node in analyzer errors
[ ] '' in errors
[ ] Evaluate casts properly

Emitter:

[ ] Get rid of global state in registers and labels
[ ] Clean up value moving code
[ ] Free operands before use, so can do things like:
      mov rbx, dword ptr [rbp+16]
      mov _rbx_, dword ptr [rbx+8]
[ ] Get rid of &regs[] use outside reg.c
    - Make stack operations
    - Differentiate between top and base operands
[ ] Short circuit ops optimization
    - If flag condition is the same, just return flags :D
      This chains well
[ ] Extra layer between emitter and assembly?
    - Expand operand?
    - Maybe: have a layer that takes expressions and an operation,
      sends them off to emitterValue, handles operands and reg
      placement.
[ ] Use temporary file (or pipe?) for output unless -[sSx]
[x] Move big pushes code into asm-amd64.c
[ ] Registers saving (possibly other ABI issues)
