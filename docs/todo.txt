Legend:     [x] Finished task   [-] Partially complete task   [ ] Unstarted task
             -  Information      o  Option

High importance:

[-] const
	[x] Parsing
	[x] Type annotation
	[ ] Type compatibility/equality
	[-] Assignable
		[ ] structs with const fields
	[ ] Fields of const structs/unions const themselves
[ ] Review type compatibility
	[ ] Cast compatibility
[ ] Numeric type coercion: widening & narrowing
[-] Type completeness
	[ ] Incomplete arrays
	[ ] Cast to incomplete
[-] Varargs
[-] extern
[-] static
    [ ] Function linkage
    [ ] Disallow all others?
[ ] Disallow global variables
[-] Modules
    [ ] Separated namespaces
    [x] Include once only

Medium:

[-] Platform support
	[-] 64-bit
		[-] Windows
		[-] Linux
	[x] 32-bit
	[-] Cross-compilation by command line
[ ] Unsigned integers
[ ] Floating point numbers
[ ] long (long long)
[ ] wchar_t
[ ] x ?: y
[ ] String literal concatenation
[x] % /
[ ] >> <<
[ ] assert
[ ] Warnings
	[ ] main conformance
	[ ] Unused value
	[ ] Statement without effect
	[ ] Empty decl
	[ ] Empty block body, if (...);
	[ ] Assignment as condition
[ ] AST optimizer
	[ ] Strength reduction
	[ ] Constant folding
	[ ] Constant propogation?
	[ ] Factorization (CSE)
	[ ] Operand commutation => Strahler number

Low:

[ ] Pretty printing control by command line
[ ] string
[ ] New IR
    - Expression only (to start with)
[ ] Designated initializers in compound literals
[ ] Lexer errors
    [ ] Multichar
    [ ] EOF without EOL
    [ ] Unended comment / string / char
    [ ] Unrecognised escape
	[ ] Newline in string
[ ] Modules
    [ ] header & using, special meaning?
	[ ] Different dialect?
        - No impls
		- No static
		- No globals (except extern)
[ ] Initializing arrays from strings
[ ] Expand eval.c
    [ ] String literals and indexing
    [ ] Records and arrays
[-] Full ABI conformance
	- structs, bah
	- GCC
	- Clang
	  Doing something weird with struct returning, LTO across module boundaries?


Other issues:

[ ] Add symbol size back to debug output
[ ] Use jump tables in tag string lookup
[-] Use vector in:
	[ ] ast
	[x] sym
[ ] Evaluate astEmpty as void, use in return / skipped field analysis/emission?

Parser:

[x] Fix AST node location
[-] Symbol shadowing
[ ] Get tokenMatch to guess whether to skip based on similarity of tokens
[ ] Complain about keywords as idents
[ ] Implicit declarations on error
[ ] Error for unnamed structs/unions that don't define variables
	- OUTSIDE structs/unions (those would be anonymous, not unnamed... because the difference is obvious)
[ ] Missing semicolon after decl (more?) shouldn't cascade so terribly

Semantic analyzer:

[ ] Array size detection (basic x[] = {...})
    - analyzer-decl.c
[ ] Check that fn impl and var init are semantically valid
[-] Make sure prototypes and implementation match exactly (static)
[ ] Initialization of extern and typedef
[ ] Evaluate casts properly
[ ] Ternary: allow compatible unequal?
[ ] typedef unification
[ ] On error expected type, chain types together and only complain again if found type not in chain?
[ ] eval.c: casts, target sizes
[ ] Improve errors for compound initializations: symbol name, type
[ ] Very strict enum coercion: from enum to integer of same size?

Emitter:

[-] Remove global state
	[x] labels
	[ ] registers
	[ ] debug?
[-] Short circuit ops optimization
    - If flag condition is the same, just return flags :D
      This chains well
[ ] Extra layer between emitter and assembly?
    - Expand operand?
    - Maybe: have a layer that takes expressions and an operation,
      sends them off to emitterValue, handles operands and reg
      placement.
[ ] Use temporary file (or pipe?) for output unless -[sSx]
[-] Let asm stuff return operand?
[ ] requestReturn for eax
[ ] Cache sym size
	=> move to analyzer?
	=> as well as offset
	=> offsetOf?
	=> eval.c
[ ] Optimize pointer indexing similar to array indexing
